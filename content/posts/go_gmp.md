---
title: "GMP"
date: 2022-10-23
draft: false
tags : [                    # 文章所属标签
    "go",
]
categories : [              # 文章所属标签
    "技术",
]
---


# Go调度器的调度过程

**G**: goroutine，不限制数量；
**M**: machine，代表一个线程，最大1万
所有G任务还是在M上执行；
**P**: Processor，代表一个处理器，每一个允许的M都会绑定一个G，默认与逻辑CPU数量相等（通过runtime.GOMAXPROCS(runtime.NumCPU())）设置。

### 调用过程 1

创建一个G对象
如果还有空闲的的P，创建一个M
M会启动一个底层线程，循环执行能找到的G
G的执行顺序是先从本地队列找，本地没找到从全局队列找。一次性转移(全局G个数/P个数）个，再去其它P中找（一次性转移一半）
以上的G任务是按照队列顺序执行（也就是go函数的调用顺序）。
另外在启动时会有一个专门的sysmon来监控和管理，记录所有P的G任务计数schedtick。如果某个P的schedtick一直没有递增，说明这个P一直在执行一个G任务，如果超过一定时间就会为G增加标记，并且该G执行非内联函数时中断自己并把自己加到队尾。

### 调用过程 2

参考图![gmp](https://www.mineor.xyz/images/20221023/gmp.png)
首先创建一个G对象，然后G被保存在P的本地队列或者全局队列（global queue）。这时P会唤醒一个M。P按照它的执行顺序继续执行任务。M寻找一个空闲的P，如果找得到，将G移动到它自己。然后M执行一个调度循环：调用G对象->执行->清理线程->继续寻找Goroutine。
在M的执行过程中，上下文切换随时发生。当切换发生，任务的执行现场需要被保护，这样在下一次调度执行可以进行现场恢复。M的栈保存在G对象，只有现场恢复需要的寄存器(SP,PC等)，需要被保存到G对象。
如果G对象还没有被执行，M可以将G重新放到P的调度队列，等待下一次的调度执行。当调度执行时，M可以通过G的vdsoSP, vdsoPC 寄存器进行现场恢复。
1. P队列 P有2种类型的队列：
2. 本地队列：本地的队列是无锁的，没有数据竞争问题，处理速度比较高。
3. 全局队列：是用来平衡不同的P的任务数量，所有的M共享P的全局队列。
4. 线程清理 G的调度是为了实现P/M的绑定，所以线程清理就是释放P上的G，让其他的G能够被调度。
5. 主动释放(active release)：典型的例子是，执行G任务时，发生了系统调用(system call)，这时M会处于阻塞（Block）状态。调度器会设置一个超时时间，来释放P。
6. 被动释放(passive release)：如果系统调用发生，监控程序需要扫描处于阻塞状态的P/M。 这时，超时之后，P资源会回收，程序被安排给队列中的其他G任务。
7. P的数量由GOMAXPROCS环境变量，或者runtime中GOMAXPROCS()函数决定的。 M的数量在runtime/debug包的SetMaxThreads()决定。如果当前的M阻塞，就会新建一个新的线程。

M的数量和P的数量没有关系。如果当前的M阻塞，P的goroutine会运行在其他的M上，或者新建一个M。所以可能出现有很多个M，只有1个P的情况。