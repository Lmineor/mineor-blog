---
title: TCP协议头部数据
draft: true
date: 星期四, 七月 17日 2025, 2:17:06 下午
tags:
  - 数通
---
# TCP协议头部数据

有20B大小的固定首部
![图](../../../images/network/tcp_header.png)
### 字段说明
序号：在一个TCP连接中传送的字节流中的每个字节都按顺序编号，本字段表示本报文段所发送的数据的**第一个字节的序号**。
确认号：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明到序号N-1为止的所有数据都已正确收到。
数据偏移（首部长度）：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B为单位，即一个数值是4B。
紧急位URG：URG=1时，表明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。
确认位ACK：ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1.  
推送位PSH：PSH=1时，接收方尽快交付接收应用进程，不用等到缓存填满再向上交付。
复位RST：RST=1时，表明TCP连接中出现严重差错，必须释放连接然重新建立传输连接
同步位SYN：SYN=1时，表明是一个连接请求/连接接收报文。
终止位FIN：FIN=1时，表明此报文发送方数据已发完，要求释放连接。
窗口：指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。
校验和：检验首部+数据，检验时要加上12B伪首部，第四个字段为6.
紧急指针：URG=1时才有意义，指出本报文段中紧急数据的字节数
选项：最大报文段长度MSS、窗口扩大、时间戳、选择确认。。。
## TCP协议的特点

1. TCP面试连接（虚连接）的传输层协议
2. 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的
3. TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。**可靠有序、不丢不重。**
4. TCP提供全双工通信
	1. 发送缓存：准备发送的数据&已经发送但尚未接收到确认的数据
	2. 接收缓存：按序到达但尚未被接收应用程序读取的数据&不按序到达的数据
5. TCP面相字节流：TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。（流：流入到进程或从进程流出的字节序列）。

# TCP提供可靠性连接的方式

1、序号：用来保证数据能有序提交给应用层
2、确认：确认号为期待收到的下一个报文段第一个字节的序号
3、重传：
	超时：计时器到期还没收到确认则重传对应报文
	冗余确认：当收到失序报文时向发送端发送冗余ACK

# 为什么TCP首部的开始便是源和目的端口号？

1. **快速访问关键字段**：
   - 端口号是传输层实现多路复用的核心标识。网络设备（如网卡、路由器）和操作系统内核需要快速提取端口号以决定数据包归属。将其放在首部前端（固定位置）可通过内存对齐和硬件优化加速处理，减少解析延迟。

2. **简化首部解析逻辑**：
   - TCP首部长度可变（因选项字段存在），但前20字节（含端口号、序列号等）是固定的。将端口号放在开头允许接收方即使不解析整个首部也能立即确定目标应用，提升处理效率。例如，负载均衡器可能仅需检查端口即可转发流量。

3. **历史与协议演进因素**：
   - TCP/IP协议栈早期设计中，处理能力有限，字段顺序需优先满足关键功能。端口号作为连接标识的首要信息，其位置反映了"重要字段优先"的设计原则。后续扩展（如选项字段）被置于尾部以保持兼容性。

4. **与UDP的一致性**：
   - UDP首部同样将端口号置于前端，这种对称性简化了协议栈的实现（如共用相同的数据包分类代码），同时降低开发者的认知负担。

5. **网络字节序与对齐优化**：
   - 端口号占2字节，放在首部起始处可确保其位于自然对齐边界（16位），避免某些架构上的未对齐内存访问开销，这对性能敏感的报文处理尤为重要。

**实际影响示例**：
- **NAT设备**：需要频繁修改端口号，前置布局可减少内存偏移计算。
- **内核协议栈**：通过预取端口号快速匹配socket连接，无需加载整个首部。
- **硬件Offload**：网卡可直接过滤特定端口流量，前置字段便于硬件电路设计。

# TCP 拥塞控制四个阶段？

TCP 拥塞控制 **四个阶段** 按时间顺序：

1. **慢启动**（Slow Start）  
   每收到一个 ACK，拥塞窗口 `cwnd` 指数级增长（+1 MSS → +2 MSS → +4 MSS …）。

2. **拥塞避免**（Congestion Avoidance）  
   当 `cwnd ≥ ssthresh`，进入线性增长，每 RTT 只加 1 MSS，避免过快拥塞。

3. **快重传**（Fast Retransmit）  
   收到 **3 个重复 ACK** 立即重传丢失段，不等超时。

4. **快恢复**（Fast Recovery）  
   把 `ssthresh` 设为 `cwnd/2`，`cwnd = ssthresh + 3 MSS`（已收到 3 个重复 ACK），然后每再收到一个重复 ACK，`cwnd` 加 1 MSS；收到新 ACK 后退出快恢复，回到拥塞避免阶段。

一句话总结  
“慢启动指数冲，拥塞避免线性爬，丢包触发快重传，快恢复后线性继续。”