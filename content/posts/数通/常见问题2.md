
# OSI（开放系统互连参考模型）7层

  

## 说明
  

![osi](../../../static/images/network/OSI.jpg)

  

- **应用层（7）**

用户与网络的界面（最复杂的一层）。

协议：FTP，SMTP，HTTP

- **表示层（6）**

处理在两个通信系统中交换信息的表示方式（采用抽象的标准方法定义数据结构）数据压缩，加解密

- **会话层（5）**

利用传输层的服务，建立进程间的同步（SYN）

- **传输层（4）（运输层）**

传输单位：报文段（TCP）或用户数据段（UDP），负责主机间进程的通信（面向连接）；端到端，可靠传输服务。

功能：流量控制，差错控制，服务质量，数据传输管理等服务：

协议：TCP，UDP

- **网络层（3）**

单位：数据报/分组

任务：把网络层的协议数据单元（分组）从源端到目的端，关键问题（路由选择）

功能：流量控制，拥塞控制，差错控制，网际互联。

协议：IP，IPX，ICMP，ARP，RARP，OSPF。有可靠传输与不可靠传输。

- **数据链路层（2）**

单位：帧

任务：将网络层传来的IP数据报组装成帧

功能：成帧，差错控制，流量控制，传输管理

一个子层：介质访问子层（MAC子层）：控制对共享信道的访问

协议：SDLC，HDLC，PPP，STP，帧中继

- **物理层（1）**

单位：比特

任务：透明传输比特流，定义数据终端设备（DTE）和数据通信设备（DCE）的物理与逻辑连接方法。
## 5 Post和Get

[GET和POST有什么区别？及为什么网上的多数答案都是错的](http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html)

[知乎回答](https://www.zhihu.com/question/31640769?rf=37401322)

  

get: [RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1](http://tools.ietf.org/html/rfc2616#section-9.3)

post: [RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1](http://tools.ietf.org/html/rfc2616#section-9.5)

  
  
  

## 6 Cookie和Session

  

|      | Cookie                     | Session |
| :--- | :------------------------- | :------ |
| 储存位置 | 客户端                        | 服务器端    |
| 目的   | 跟踪会话，也可以保存用户偏好设置或者保存用户名密码等 | 跟踪会话    |
| 安全性  | 不安全                        | 安全      |
 
session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。


## 7 apache和nginx的区别

nginx 相对 apache 的优点：
* 轻量级，同样起web 服务，比apache 占用更少的内存及资源
* 抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能
* 配置简洁
* 高度模块化的设计，编写模块相对简单
* 社区活跃

apache 相对nginx 的优点：
* rewrite ，比nginx 的rewrite 强大
* 模块超多，基本想到的都可以找到
* 少bug ，nginx 的bug 相对较多
* 超稳定  
## 9 HTTP和HTTPS
### 状态码

| 状态码       | 定义               |
| :-------- | :--------------- |
| 1xx 报告    | 接收到请求，继续进程       |
| 2xx 成功    | 步骤成功接收，被理解，并被接受  |
| 3xx 重定向   | 为了完成请求,必须采取进一步措施 |
| 4xx 客户端出错 | 请求包括错的顺序或不能完成    |
| 5xx 服务器出错 | 服务器无法完成显然有效的请求   |

403: Forbidden

404: Not Found

  

### 状态码详解

| 状态码 | 状态                    | 方法             | 定义                                    |
| :-- | :-------------------- | :------------- | :------------------------------------ |
| 200 | OK                    | GET            | 服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。   |
| 201 | CREATED               | POST/PUT/PATCH | 用户新建或修改数据成功。                          |
| 202 | Accepted              | \*             | 表示一个请求已经进入后台排队（异步任务）                  |
| 204 | NO CONTENT            | DELETE         | 用户删除数据成功。                             |
| 400 | INVALID REQUEST       | POST/PUT/PATCH | 用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 |
| 401 | Unauthorized          | \*             | 表示用户没有权限（令牌、用户名、密码错误）。                |
| 403 | Forbidden             | \*             | 表示用户得到授权（与401错误相对），但是访问是被禁止的。         |
| 404 | NOT FOUND             | \*             | 用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。  |
| 406 | Not Acceptable        | GET            | 用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。   |
| 410 | Gone                  | GET            | 用户请求的资源被永久删除，且不会再得到的。                 |
| 422 | Unprocesable entity   | POST/PUT/PATCH | 当创建一个对象时，发生一个验证错误。                    |
| 500 | INTERNAL SERVER ERROR | \*             | 服务器发生错误，用户将无法判断发出的请求是否成功。             |

### HTTP  

#### HTTP优化方案：

1. TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能
2. 内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。
3. 压缩：将文本数据进行压缩，减少带宽
4. SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速
5. TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。 

#### HTTP1.0 HTTP 1.1主要区别
  
- 长连接

HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。
HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。
- 节约带宽
HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。
这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。
另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。
- HOST域
现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。
HTTP1.0是没有host域的，HTTP1.1才支持这个参数。

HTTP1.1 HTTP 2.0主要区别
- 多路复用
HTTP2.0使用了(类似epoll)多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。
TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。
- 数据压缩
HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
- 服务器推送
意思是说，当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。
服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。 

#### URI和URL  

各自的组成

1. URI
Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的；
URI一般由三部组成
①访问资源的命名机制
②存放资源的主机名
③资源自身的名称，由路径表示，着重强调于资源。

2. URL

URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。
采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。
URL一般由三部组成
①协议(或称为服务方式)
②存有该资源的主机IP地址(有时也包括端口号)
③主机资源的具体地址。如目录和文件名等
URI：Uniform Resource Identifier，统一资源标识符
URL：Uniform Resource Location统一资源定位符 

##### 关系

URI是一个用于标识互联网资源名称的字符串。 该种标识允许用户对网络中（一般指万维网）的资源通过特定的协议进行交互操作。URI的最常见的形式是统一资源定位符（URL），经常指定为非正式的网址。更罕见的用法是统一资源名称（URN），其目的是通过提供一种途径。用于在特定的命名空间资源的标识，以补充网址。
通俗地说，URL和URN是URI的子集，URI属于URL更高层次的抽象，一种字符串文本标准。
##### 有什么区别 

- URI，是统一资源标识符，用来唯一的标识一个资源。
- URL是统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。
- URN，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。

  
也就是说，URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI；

URL是URI的一种。但也不是所有的URI都是URL哦，就好像蝴蝶都会飞，但会飞的可不都是蝴蝶啊！

让URI能成为URL的当然就是那个“访问机制”，“网络位置”。e.g. http://

or ftp://.。URN是唯一标识的一部分，就是一个特殊的名字。

  
  
  

#### 什么是Http协议无状态协议?怎么解决Http协议无状态协议?

无状态协议对于事务处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息

也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个"老用户"。

可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是"老用户"。

  

### HTTP与HTTPS的区别：

1. HTTP 的URL 以http://开头，而HTTPS 的URL 以https://开头

2. HTTP 是不安全的，而 HTTPS 是安全的

3. HTTP 标准端口是80 ，而 HTTPS 的标准端口是443

4. 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层（SSL TLS工作在会话层）

5. HTTP 无法加密，而HTTPS 对传输的数据进行加密

6. HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书

  

### HTTPS  

HTTPS协议 = HTTP协议 + SSL/TLS协议 

- SSL的全称是Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。SSL协议在1994年被Netscape发明，后来各个浏览器均支持SSL，其最新的版本是3.0
- TLS的全称是Transport Layer Security，即安全传输层协议，最新版本的TLS（Transport Layer Security，传输层安全协议）是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的加密算法不同，所以TLS与SSL3.0不能互操作。  

虽然TLS与SSL3.0在加密算法上不同，但是在我们理解HTTPS的过程中，我们可以把SSL和TLS看做是同一个协议。  

HTTPS为了兼顾安全与效率，同时使用了**对称加密**和**非对称**加密。  

对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。  

过程图示意:

![示意](../src/https.png)
 
详解：

一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。

1.客户端向服务器发起HTTPS请求，连接到服务器的443端口

2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。

3.服务器将自己的公钥发送给客户端。

4.客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。

5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。

6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。

7.然后服务器将加密后的密文发送给客户端。

8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。

  

### HTTPS在传输的过程中会涉及到三个密钥

  

- 服务器端的公钥和私钥，用来进行非对称加密

- 客户端生成的随机密钥，用来进行对称加密

  
  

## 10 XSRF和XSS

  

* CSRF(Cross-site request forgery)跨站请求伪造

* XSS(Cross Site Scripting)跨站脚本攻击

  

CSRF重点在请求,XSS重点在脚本

  

## 11 幂等 Idempotence

  

HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的**副作用**。(注意是副作用)

  

`GET http://www.bank.com/account/123456`，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。`GET http://www.news.com/latest-news`这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。

  

DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：`DELETE http://www.forum.com/article/4231`，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。

  
  

POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：`POST http://www.forum.com/articles`的语义是在`http://www.forum.com/articles`下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。

  

PUT所对应的URI是要创建或更新的资源本身。比如：`PUT http://www.forum/articles/4231`的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。

  
  

## 12 RESTful架构(SOAP,RPC)

  

推荐: http://www.ruanyifeng.com/blog/2011/09/restful.html

  
  

## 13 SOAP

  

SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。

  

## 14 RPC

  

RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。

  

总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了.

  

进化的顺序: RPC -> SOAP -> RESTful

  

## 15 CGI和WSGI

CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。

CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。

  

WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。

  

官方说明：[PEP-3333](https://www.python.org/dev/peps/pep-3333/)

  

## 16 中间人攻击

  

在GFW里屡见不鲜的,呵呵.

  

中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。

  

## 17 c10k问题

  

所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。

推荐: https://my.oschina.net/xianggao/blog/664275

  

## 18 socket

  

推荐: http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml

  

Socket=Ip address+ TCP/UDP + port

  

## 19 浏览器缓存

  

推荐: http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html

  

304 Not Modified

  

## 20 HTTP1.0和HTTP1.1

  

推荐: http://blog.csdn.net/elifefly/article/details/3964766

  

1. 请求头Host字段,一个服务器多个网站

2. 长链接

3. 文件断点续传

4. 身份认证,状态管理,Cache缓存

  

HTTP请求8种方法介绍

HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。

  

GET

  

GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。

  

GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。

  

HEAD

  

HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。

  

POST

  

POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。

  

PUT

  

PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。

  

DELETE

  

DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。

  

CONNECT

  

CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。

  

OPTIONS

  

OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许

  

TRACE

  

TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。

  

HTTP/1.1之后增加的方法

  

在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：

  

PATCH

  

PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：

  

但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。

当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。

  

## 21 Ajax

AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。

  
  

## 22 Nginx

  

### Nginx支持的负载均衡调度算法

- 轮询（weight，默认）：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。这种方式下，可以给不同的后端服务器设置一个权重值（weight），用于调整不同的服务器上请求的分配率。权重的数值越大，被分配到请求的几率越大。权重值可以根据不同的后端服务器的硬件配置进行调整，在配置的server后面加上weight=number修改权重值，这种方式叫做加权轮询。

- IP绑定（ip_hash）：每个请求按照发起客户端的IP的hash结果进行匹配，同样IP地址的客户端总是会访问同一个后端服务器，在一定程度上解决了集群部署环境下Session共享的问题。

- 最快响应时间（fair）：智能调度算法，动态地根据后端服务器的处理处理效率和响应时间对请求进行均衡分配，响应时间短、处理效率高的服务器分配到请求的概率高，响应时间长、处理效率低的服务器分配到请求的概率低。使用这种算法需要安装upstream_fair模块。

- URL绑定（url_hash）：按照访问的URL的hash结果分配请求，相同的URL会访问同一个后端服务器，在一定程度上可以提高缓存的效率。使用这种算法需要安装Nginx的hash软件包。

- 最小连接数（least_conn）：优先将请求分配给压力较小的后端服务器，这样可以平衡每个后端服务器下等待队列的长度，并避免向压力大的服务器添加更多的请求。

  

## 23 从输入网址到获得页面的网络请求的过程

- （1）域名解析，其实就是根据用户输入的网址去寻找它对应的IP地址，比如输入www.baidu.com的网址就会经历以下过程

1.先从浏览器缓存里找IP,因为浏览器会缓存DNS记录一段时间

2.如没找到,再从Hosts文件查找是否有该域名和对应IP

3.如没找到,再从路由器缓存找

4.如没找到,再从DNS缓存查找

5.如果都没找到,浏览器域名服务器向根域名服务器(baidu.com)查找域名对应IP,还没找到就把请求转发到下一级,直到找到IP

  

- （2）建立TCP连接 （这里使用五层协议更详细的描述如何建立这个TCP链接的）

先是客户端发起请求过程：

1. 使用应用层发起HTTP请求（这个可以根据你本身输入的url访问时，用的什么协议就发起对应协议去进行请求）

2. 然后是传输层的TCP协议为传输报文提供可靠的字节流服务，这里也就使用了TCP三次握手

3. 网络层是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址

4. 然后才是链路层将数据发送到数据链路层传输。至此请求报文已发出，客户端发送请求的阶段结束

  

然后是服务端接受请求处理阶段：

原路进行处理：链路层—>网络层—>传输层—>应用层然后响应客户端发送报文。

  

- （3）根据SpringMVC后台业务返回数据，并把数据填充到HTML页面上，然后返回给浏览器

  
  

- （4）浏览器进行处理

服务器通过后台语言程序处理,找到数据返回给浏览器,HTML字符串被浏览器接受后被一句句读取解析,解析到link标签后重新发送请求获取css,解析到sript标签后发送请求获取js,并执行代码

  

- （5）绘制网页

然后浏览器会进行渲染，浏览器根据HTML和CSS计算得到渲染树,绘制到屏幕上,js会被执行

  

参考：https://blog.csdn.net/qq_36520235/article/details/82559847