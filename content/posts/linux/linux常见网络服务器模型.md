Linux 下常见的网络服务器模型大致可以分为五类：**阻塞模型、多进程模型、多线程模型、I/O 多路复用模型、异步事件驱动模型**。下面按照演进顺序和典型实现逐一梳理，并给出优缺点与适用场景。

---

### 1. 阻塞模型（Blocking / Iterative）
- **原理**：单进程/线程，主循环 accept → read → write，所有操作阻塞。
- **代码示例**：
  ```c
  while (1) {
      connfd = accept(listenfd, ...);
      read(connfd, buf, ...);
      write(connfd, buf, ...);
      close(connfd);
  }
  ```
- **优点**：实现简单，适合学习。
- **缺点**：无法并发，一个连接阻塞所有后续连接。
- **适用**：C10、测试、教学。

---

### 2. 多进程模型（Prefork / Fork-per-Connection）
- **原理**：每来一个连接 `fork()` 一个子进程处理。
- **典型实现**：早期 Apache MPM prefork、vsftpd。
- **优点**：
  - 进程隔离，稳定性好。
  - 可配合特权分离（如 80 端口后降权）。
- **缺点**：
  - 进程创建/销毁开销大（C1000 以上性能差）。
  - 进程间内存占用高（写时复制缓解但有限）。
- **优化**：**Prefork 池**（启动时预创建进程，减少 fork 开销）。

---

### 3. 多线程模型（Thread-per-Connection）
- **原理**：每连接创建一个线程处理，共享进程地址空间。
- **典型实现**：Java BIO（如 Tomcat NIO 之前）、MySQL 每个连接一个线程。
- **优点**：
  - 线程创建比进程轻量。
  - 共享内存，IPC 成本低。
- **缺点**：
  - 线程栈默认 8MB，高并发时内存耗尽（C10K 问题）。
  - 线程切换开销随并发数线性增长。
- **优化**：**线程池**（固定线程数，任务队列复用）。

---

### 4. I/O 多路复用模型（Reactor 模式）
基于 **select/poll/epoll** 等系统调用，单线程/进程监听多个 FD 事件。

#### 4.1 select/poll
- **原理**：轮询 FD 集合，返回就绪事件。
- **缺点**：
  - select 最多 1024 FD（硬编码）。
  - 每次调用需拷贝 FD 集合到内核（O(n) 复杂度）。

#### 4.2 epoll（Linux 特有）
- **原理**：事件驱动，内核维护就绪链表，仅返回活跃 FD（O(1)）。
- **两种触发模式**：
  - **LT（水平触发）**：默认，类似 poll，需处理完所有数据。
  - **ET（边缘触发）**：高速模式，仅通知一次，需非阻塞读写。
- **典型实现**：
  - **Nginx**：单线程 epoll + 非阻塞 IO（Master-Worker 多进程）。
  - **Redis**：单线程 epoll（处理命令） + 后台线程（AOF、RDB）。
  - **libevent/libev**：跨平台封装（epoll/kqueue）。

#### 4.3 多线程 Reactor
- **原理**：主线程 epoll 监听，工作线程池处理业务（如 Memcached）。
- **优点**：
  - 单线程可支撑 C10K 甚至 C100K（依赖 CPU 和内存）。
  - 避免上下文切换开销（相比 Thread-per-Connection）。

---

### 5. 异步事件驱动模型（Proactor 模式）
- **原理**：利用操作系统异步 IO（如 Linux AIO、io_uring），内核完成数据读写后通知应用。
- **典型实现**：
  - **io_uring**：Linux 5.1+ 提供的异步接口，减少系统调用开销。
  - **Windows IOCP**：Windows 下的 Proactor 实现。
- **优点**：
  - 真正的异步，CPU 零拷贝（如 DMA 直接到用户缓冲区）。
  - 适合高吞吐场景（如磁盘 IO、网络代理）。
- **缺点**：
  - 编程复杂，调试困难。
  - Linux AIO 早期实现不完善（io_uring 已大幅改善）。

---

### 模型对比表
| 模型                | 并发能力 | 内存占用 | CPU 开销 | 复杂度 | 典型应用               |
|---------------------|----------|----------|----------|--------|------------------------|
| 阻塞                | 1        | 低       | 低       | 极低   | 测试程序               |
| 多进程              | 低       | 高       | 高       | 低     | Apache prefork         |
| 多线程              | 中       | 中       | 中       | 中     | MySQL、Java BIO        |
| epoll 单线程        | 高       | 低       | 低       | 中     | Redis、Nginx           |
| epoll + 线程池      | 很高     | 中       | 中       | 高     | Memcached、Nginx 多线程|
| 异步 IO（io_uring） | 极高     | 低       | 极低     | 极高   | 高性能代理、存储系统   |

---

### 总结选择
- **C10K 问题**：优先 epoll 单线程（Nginx/Redis）。
- **CPU 密集**：多线程/多进程（如计算型服务）。
- **高吞吐异步**：io_uring（如 Cloudflare 的 quiche）。
- **简单场景**：阻塞或多线程池（如 Python Flask 默认 WSGI）。

理解这些模型后，可以进一步学习 **Zero-Copy**（sendfile、splice）、**RPS/RFS**（网卡多队列）等优化手段。